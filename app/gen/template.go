package gen

import (
	"fmt"
	"github.com/goal-web/supports/logs"
	"log"
	"os"
	"strings"
	"text/template"
)

var defaultTemplate = []byte("{{- define \"model\" -}}\npackage {{ .Package }}\n  \nimport (\n    \"encoding/json\"\n    \"github.com/goal-web/supports/logs\"\n    \"github.com/goal-web/contracts\"\n    \"github.com/goal-web/database/table\"\n    \"github.com/goal-web/supports/utils\"\n    \"github.com/goal-web/collection\"\n    {{- if .Model.Authenticatable }}\n    \"fmt\"\n    {{- end }}\n    {{- if hasMsgComment .Model \"@carbon\" }}\n    \"github.com/golang-module/carbon/v2\"\n    {{- end }}\n    {{- range .Imports }}\n    {{ .Alias }} \"{{ .Pkg }}\"\n    {{- end }}\n)\n\n{{- $modelName := .Model.Name }}\n{{- $rawName := .Model.RawName }}\n{{- $tableName := .Model.TableName }}\n{{- $primaryKey := .Model.PrimaryKey }}\n\n\nvar (\n    {{- range .Relations }}\n    {{ $rawName }}{{ .Name }}Relation contracts.RelationType = \"{{ .JSONName }}\"\n    {{- end }}\n)\n\n{{- $define := join $rawName \"Define\" }}\nvar {{ $define }} {{ $rawName }}Static\n\ntype {{ $rawName }}Static struct {\n\tHidden []string\n\tWith []contracts.RelationType\n\tAppends map[string]func(model *{{ $modelName }}) any\n\n  {{- range .Fields }}\n  {{ .Name }}Getter func(model *{{ $modelName }}, raw {{ goType . }}) {{ goType . }}\n  {{ .Name }}Setter func(model *{{ $modelName }}, raw {{ goType . }}) {{ goType . }}\n  {{- end }}\n\n  Saving   func(model *{{ $modelName }}) contracts.Exception\n  Saved    func(model *{{ $modelName }})\n  Updating func(model *{{ $modelName }}, fields contracts.Fields) contracts.Exception\n  Updated  func(model *{{ $modelName }}, fields contracts.Fields)\n  Deleting func(model *{{ $modelName }}) contracts.Exception\n  Deleted  func(model *{{ $modelName }})\n  PrimaryKeyGetter func(model *{{ $modelName }}) any\n}\n\nfunc init() {\n    {{- if hasMsgComment .Model \"@hidden\" }}\n    {{ $define }}.Hidden = append(\n        {{ $define }}.Hidden,\n        {{- range .Fields }}\n            {{- if hasComment .Comment \"@hidden\" }}\n            \"{{ .JSONName }}\",\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n\n    {{- if hasMsgComment .Model \"@with\" }}\n    {{ $define }}.With = append(\n        {{ $define }}.With,\n        {{- range .Relations }}\n            {{- if hasComment .Comment \"@with\" }}\n             {{ $rawName }}{{ .Name }}Relation,\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n}\n\nfunc New{{ $modelName }}(fields contracts.Fields) *{{ $modelName }} {\n  var model = {{ $modelName }}{\n    _raw: fields,\n  }\n  model.Set(fields)\n  return &model\n}\n\nfunc {{ $modelName }}SingleRelationSetter[T any](key contracts.RelationType) func(item *{{ $modelName }}, value []any) {\n    return func(item *{{ $modelName }}, values []any) {\n        var value T\n        if len(values) > 0 {\n            value = values[0].(T)\n        }\n        item.Set(contracts.Fields{\n            string(key): value,\n        })\n    }\n}\nfunc {{ $modelName }}MultiRelationSetter[T any](key contracts.RelationType) func(item *{{ $modelName }}, value []any) {\n    return func(model *{{ $modelName }}, value []any) {\n        var results []T\n        for _, item := range value {\n            results = append(results, item.(T))\n        }\n        model.Set(contracts.Fields{ string(key): results })\n    }\n}\n\nfunc {{ $modelName }}LocalKeyGetter(key string) func(item *{{ $modelName }}) any {\n    return func(item *{{ $modelName }}) any {\n        return item.Get(key)\n    }\n}\n\n\nfunc {{ $modelName }}RelationGetter[T any](query func() contracts.QueryBuilder[T], foreignKey string) func(keys []any) map[string][]any {\n    return func(keys []any) map[string][]any {\n        var results = map[string][]any{}\n        for key, values := range query().WhereIn(foreignKey, keys).Get().GroupBy(foreignKey) {\n            results[key] = collection.New(values).ToAnyArray()\n        }\n        return results\n    }\n}\n\n{{- $queryName := replaceSuffix .Model.Name \"Model\" \"Query\" }}\n{{- $relationLen := sub (len .Relations) 1 }}\nfunc {{ $queryName }}() contracts.QueryBuilder[{{ $modelName }}] {\n  return table.NewQuery(\"{{ $tableName }}\", New{{ $modelName }}).\n    SetPrimaryKey(\"{{ $primaryKey }}\").\n    {{- range $index, $item := .Relations }}\n        {{- $relationType := join $rawName  .Name \"Relation\" }}\n        {{- $relationItemType := substring (goType .) 1 }}\n        {{- $relationQuery := replaceSuffix $relationItemType \"Model\" \"Query\"}}\n\n        {{- if hasComment .Comment \"@belongsTo\" }}\n            {{- $ownerKey := getIndexComment .Comment \"@belongsTo\" 0 \"id\" }}\n            {{- $localKey := getIndexComment .Comment \"@belongsTo\" 1 (join .JSONName \"_id\") }}\n            SetRelation( // belongsTo\n            {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}RelationGetter({{ $relationQuery }}, \"{{ $ownerKey }}\"),\n                        {{ $modelName }}SingleRelationSetter[*{{ $relationItemType }}]({{ $relationType }}),\n            ).\n        {{- else if hasComment .Comment \"@hasOne\" }}\n         {{- $localKey := getIndexComment .Comment \"@hasOne\" 0 \"id\" }}\n         {{- $foreignKey := getIndexComment .Comment \"@hasOne\" 1 (join (toLower $rawName) \"_id\") }}\n                    SetRelation( // hasOne\n                    {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}RelationGetter({{ $relationQuery }}, \"{{ $foreignKey }}\"),\n                        {{ $modelName }}SingleRelationSetter[*{{ $relationItemType }}]({{ $relationType }}),\n                    ).\n        {{- else if hasComment .Comment \"@hasMany\" }}\n         {{- $relationItemType := substring (goType .) 2 }}\n         {{- $relationQuery := replaceSuffix (substring (goType .) 3) \"Model\" \"Query\"}}\n         {{- $foreignKey := getIndexComment .Comment \"@hasMany\" 0 (join (toLower $rawName) \"_id\") }}\n         {{- $localKey := getIndexComment .Comment \"@hasMany\" 1 \"id\" }}\n                    SetRelation( // hasMany\n                    {{ $rawName }}{{ .Name }}Relation,\n                        {{ $modelName }}LocalKeyGetter(\"{{ $localKey }}\"),\n                        {{ $modelName }}RelationGetter({{ $relationQuery }}, \"{{ $foreignKey }}\"),\n                        {{ $modelName }}MultiRelationSetter[{{ $relationItemType }}]({{ $relationType }}),\n                    ).\n        {{- end }}\n\n    {{- end }}\n     With({{ $define }}.With...)\n}\n\n{{ toComments .Model.Name .Model.Comments }}\ntype {{ $modelName }} struct {\n  {{- range .Fields }}\n  {{- if hasComment .Comment \"@belongsTo\" }}\n  {{- else }}\n  {{ .Comments }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n  {{- end }}\n\n  _raw contracts.Fields\n  _update contracts.Fields\n  _append contracts.Fields\n  _hidden map[string]struct{}\n\n  _relation_loaded map[contracts.RelationType]struct{}\n  {{- range .Relations }}\n    _{{ .Name }} {{ goType . }}\n  {{- end }}\n}\n\nfunc (model *{{ $modelName }}) Hidden(fields ...string) *{{ $modelName }} {\n    for _, field := range fields {\n        if model._hidden == nil {\n            model._hidden = map[string]struct{}{\n                field: struct{}{},\n            }\n        } else {\n            model._hidden[field] = struct{}{}\n        }\n\n    }\n\n    return model\n}\n\nfunc (model *{{ $modelName }}) Exists() bool {\n  return {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).Count() > 0\n}\n\nfunc (model *{{ $modelName }}) Save() contracts.Exception {\n  if model._update == nil {\n    return nil\n  }\n  if {{ $define }}.Saving != nil {\n    if err := {{ $define }}.Saving(model); err != nil {\n      return err\n    }\n  } \n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).UpdateE(model._update)\n  if err == nil {\n    model._update = nil\n    if {{ $define }}.Saved != nil {\n      {{ $define }}.Saved(model)\n    }\n  }\n  \n  return err\n}\n\nfunc (model *{{ $modelName }}) Set(fields contracts.Fields) {\n  for key, value := range fields {\n\n    switch key {\n  {{- range .Fields }}\n      case \"{{ .JSONName }}\":\n        switch v := value.(type) {\n                case {{ goType . }}:\n                  model.Set{{ .Name }}(v)\n                case func() {{ goType . }}:\n                  model.Set{{ .Name }}(v())\n                  {{- $type := goType . }}\n                  {{- if ne $type \"string\"}}\n                case string:\n                  {{- if eq $type \"[]byte\" }}\n                  model.Set{{ .Name }}([]byte(v))\n                  {{else}}\n                  var vd {{ goType . }}\n                  err := json.Unmarshal([]byte(v), &vd)\n                  if err != nil {\n                      logs.Default().Warn(\"Failed to Parse field \"+key)\n                      continue\n                  }\n                  model.Set{{ .Name }}(vd)\n                  {{end}}\n                  {{end}}\n                  {{- if ne $type \"[]byte\"}}\n                case []byte:\n                  {{- if eq $type \"string\" }}\n                  model.Set{{ .Name }}(string(v))\n                  {{else}}\n                  var vd {{ goType . }}\n                  err := json.Unmarshal(v, &vd)\n                  if err != nil {\n                      logs.Default().Warn(\"Failed to Parse field \"+key)\n                      continue\n                  }\n                  model.Set{{ .Name }}(vd)\n                  {{end}}\n                  {{end}}\n                }\n    {{- end }}\n    {{- range .Relations }}\n    {{- $relationType := join $rawName  .Name \"Relation\" }}\n    case string({{ $relationType }}):\n        model.Set{{ .Name }}(value.({{ goType . }}))\n    {{- end }}\n    }\n\n  }\n}\n\nfunc (model *{{ $modelName }}) Only(key ...string) contracts.Fields {\n  var fields = make(contracts.Fields)\n  for _, k := range key {\n  {{- range .Fields }}\n    if k == \"{{ .JSONName }}\" {\n      fields[k] = model.Get{{ .Name }}()\n      continue\n    }\n  {{- end }}\n  \n    if {{ $define }}.Appends[k] != nil {\n     fields[k] = {{ $define }}.Appends[k](model)\n    }\n  }\n  return fields\n}\n\nfunc (model *{{ $modelName }}) Get(key string) any {\n    switch key {\n        {{- range $index, $item := .Fields }}\n            case \"{{ .JSONName }}\":\n              return model.Get{{ .Name }}()\n        {{- end }}\n    }\n\n    if value, exists := model._append[key]; exists {\n      return value\n    }\n\n    if fn, exists := {{ $define }}.Appends[key]; exists {\n        model._append[key] = fn(model)\n      return model._append[key]\n    }\n\n     switch contracts.RelationType(key) {\n            {{- range $index, $item := .Relations }}\n            {{- $relationType := join $rawName  .Name \"Relation\" }}\n                case {{ $relationType }}:\n                  return model.{{ .Name }}()\n            {{- end }}\n        }\n\n  return nil\n}\n\nfunc (model *{{ $modelName }}) Except(keys ...string) contracts.Fields {\n  var excepts = map[string]struct{}{}\n  for _, k := range keys {\n    excepts[k] = struct{}{}\n  }\n  var fields = make(contracts.Fields)\n  for key, value := range model.ToFields() {\n    if _, ok := excepts[key]; ok {\n      continue\n    }\n    fields[key] = value\n  }\n  return fields\n}\n\nfunc (model *{{ $modelName }}) ToFields() contracts.Fields {\n  model.Hidden({{ $define }}.Hidden...)\n\n  fields := contracts.Fields{}\n\n    {{- range .Fields }}\n    if _,exists := model._hidden[\"{{ .JSONName }}\"]; !exists {\n        fields[\"{{ .JSONName }}\"] = model.Get{{ .Name }}()\n    }\n    {{- end }}\n\n  for key := range {{ $define }}.Appends {\n    fields[key] = model.Get(key)\n  }\n\n  for key := range model._relation_loaded {\n    switch key {\n    {{- range .Relations }}\n    {{- $relationType := join $rawName  .Name \"Relation\" }}\n    case {{ $relationType }}:\n        {{- if .Repeated }}\n        var results []contracts.Fields\n        for _, item := range model._{{ .Name }} {\n            results = append(results, item.ToFields())\n        }\n        fields[string(key)] = results\n        {{- else }}\n        fields[string(key)] = model._{{ .Name }}.ToFields()\n        {{- end }}\n    {{- end }}\n    }\n  }\n\n  return fields\n}\n\nfunc (model *{{ $modelName }}) Update(fields contracts.Fields) contracts.Exception {\n\n  if {{ $define }}.Updating != nil {\n    if err := {{ $define }}.Updating(model, fields); err != nil {\n      return err\n    }\n  }\n\n  if model._update != nil {\n    utils.MergeFields(model._update, fields)\n  }\n\n\n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).UpdateE(fields)\n  \n  if err == nil {\n    model.Set(fields)\n    model._update = nil\n    if {{ $define }}.Updated != nil {\n      {{ $define }}.Updated(model, fields)\n    }\n  }\n  \n  return err\n}\n\nfunc (model *{{ $modelName }}) Refresh() contracts.Exception {\n  fields, err := table.ArrayQuery(\"{{ $tableName }}\").Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).FirstE()\n  if err != nil {\n    return err\n  }\n\n  model.Set(*fields)\n  return nil\n}\n\nfunc (model *{{ $modelName }}) Delete() contracts.Exception {\n  \n  if {{ $define }}.Deleting != nil {\n    if err := {{ $define }}.Deleting(model); err != nil {\n      return err\n    }\n  }\n\n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).DeleteE()\n  if err == nil && {{ $define }}.Deleted != nil {\n    {{ $define }}.Deleted(model)\n  }\n  \n  return err\n}\n\n  \nfunc (model *{{ $modelName }}) GetPrimaryKey() any {\n  if {{ $define }}.PrimaryKeyGetter != nil {\n    return {{ $define }}.PrimaryKeyGetter(model)\n  }\n  \n  return model.{{ toCamelCase $primaryKey }}\n}\n\n{{- if .Model.Authenticatable }}\nfunc (model *{{ $modelName }}) GetAuthenticatableKey() string {\n  return fmt.Sprintf(\"%v\", model.GetPrimaryKey())\n}\n\nfunc {{ .Model.RawName }}AuthProvider(identify string) contracts.Authenticatable {\n  return {{ .Model.RawName }}Query().Find(identify)\n}\n\n{{- end }}\n\n\n{{- range .Fields }}\n\nfunc (model *{{ $modelName }}) Get{{ .Name }}() {{ goType . }} {\n  if {{ $define }}.{{ .Name }}Getter != nil {\n    return {{ $define }}.{{ .Name }}Getter(model, model.{{ .Name }})\n  }\n  return model.{{ .Name }}\n}\n\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value {{ goType . }}) {\n  if {{ $define }}.{{ .Name }}Setter != nil {\n    value = {{ $define }}.{{ .Name }}Setter(model, value)\n  }\n\n  if model._update == nil {\n    model._update = contracts.Fields{\"{{ .JSONName }}\": value}\n  } else {\n    model._update[\"{{ .JSONName }}\"] = value\n  }\n  model.{{ .Name }} = value\n}\n\n{{- if hasComment .Comment \"@carbon\" }}\nfunc (model *{{ $modelName }}) Get{{ .Name }}Carbon() carbon.Carbon {\n  return carbon.Parse(model.Get{{ .Name }}())\n}\n{{- end }}\n\n\n{{- end }}\n\n{{- range .Relations }}\n{{- $relationType := join $rawName  .Name \"Relation\" }}\n{{- $relationItemType := substring (goType .) 1 }}\n{{- $relationQuery := replaceSuffix $relationItemType \"Model\" \"Query\" }}\n\n{{- if (hasComment .Comment \"@belongsTo\") }}\nfunc (model *{{ $modelName }}) {{ .Name }}() {{ goType . }} {\n    _, exists := model._relation_loaded[{{ $relationType }}]\n    if !exists {\n        value := {{ $relationQuery }}().Where(\"{{ getIndexComment .Comment \"@belongsTo\" 0 \"id\" }}\", model.Get(\"{{ getIndexComment .Comment \"@belongsTo\" 1 (join .JSONName \"_id\") }}\")).First()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return model._{{ .Name }}\n}\n\n{{- else if (hasComment .Comment \"@hasOne\") }}\n{{- $localKey := getIndexComment .Comment \"@hasOne\" 0 \"id\" }}\n{{- $foreignKey := getIndexComment .Comment \"@hasOne\" 1 (join (toLower $rawName) \"_id\") }}\nfunc (model *{{ $modelName }}) {{ .Name }}() {{ goType . }} {\n    _, exists := model._relation_loaded[{{ $relationType }}]\n    if !exists {\n        value := {{ $relationQuery }}().Where(\"{{ $foreignKey }}\", model.Get(\"{{ $localKey }}\")).First()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return model._{{ .Name }}\n}\n\n{{- else if (hasComment .Comment \"@hasMany\") }}\n\n{{- $relationItemType := substring (goType .) 3 }}\n{{- $relationQuery := replaceSuffix $relationItemType \"Model\" \"Query\" }}\n{{- $foreignKey := getIndexComment .Comment \"@hasMany\" 0 (join .JSONName \"_id\") }}\n{{- $localKey := getIndexComment .Comment \"@hasMany\" 1 \"id\" }}\n\nfunc (model *{{ $modelName }}) {{ .Name }}() {{ goType . }} {\n    _, exists := model._relation_loaded[{{ $relationType }}]\n    if !exists {\n        value := {{ $relationQuery }}().Where(\"{{ $foreignKey }}\", model.Get(\"{{ $localKey }}\")).Get().ToArray()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return model._{{ .Name }}\n}\n\n{{- end }}\n\n\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value {{ goType . }}) {\n    if model._relation_loaded == nil {\n        model._relation_loaded = make(map[contracts.RelationType]struct{})\n    }\n    model._relation_loaded[{{ $relationType }}] = struct{}{}\n    model._{{ .Name }} = value\n}\n\n{{- end }}\n\n{{ end }}\n\n\n{{- define \"data\" -}}\npackage {{ .Package }}\n  \nimport (\n{{- range .Imports }}\n{{ .Alias }} \"{{ .Pkg }}\"\n{{- end }}\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\n{{ end }}\n\n{{- define \"request\" -}}\npackage {{ .Package }}\n  \nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n  \"github.com/goal-web/contracts\"\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\nfunc (model *{{ .Model.Name }}) ToFields() contracts.Fields {\n  if model == nil {\n    return nil\n  }\n  fields := contracts.Fields{\n  {{- range .Fields }}\n    \"{{ .JSONName }}\": model.{{ .Name }},\n  {{- end }}\n  }\n  return fields\n}\n\n{{ end }}\n\n{{- define \"result\" -}}\npackage {{ .Package }}\n    \nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\n{{ end }}\n\n{{- define \"enum\" -}}\npackage {{ .Package }}\n\n{{- $enumName := .Name }}\ntype {{ .Name }} int\nconst (\n  {{- range .Values }}\n  {{- $FieldName := sprintf \"%s%s\" $enumName .Name }}\n\n  {{ toComments $FieldName .Comments }}\n  {{ $enumName }}{{ .Name }} {{ $enumName }} = {{ .Value }}\n  {{- end }}\n  {{ $enumName }}Unknown {{ $enumName }} = -1000\n      \n)\n  \n  \nfunc (item {{ $enumName }}) String() string {\n    switch item {\n      {{- range .Values }}\n        case {{ $enumName }}{{ .Name }}:\n          return \"{{ .Name }}\"\n      {{- end }}\n        default:\n          return \"Unknown\"\n  }\n}\n\nfunc (item {{ $enumName }}) Message() string {\n    switch item {\n      {{- range .Values }}\n        case {{ $enumName }}{{ .Name }}:\n          return \"{{ .Message }}\"\n      {{- end }}\n        default:\n          return \"Unknown\"\n  }\n}\n\nfunc Parse{{ $enumName }}FromString(msg string) {{ $enumName }} {\n    switch msg {\n    {{- range .Values }}\n        case \"{{ .Name }}\":\n          return {{ $enumName }}{{ .Name }}\n    {{- end }}\n        default:\n          return {{ $enumName }}Unknown\n  }\n}\n\n\n{{ end }}\n\n\n\n{{- define \"service\" -}}\npackage {{ .Package }}\n\nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n)\n\n{{- $serviceName := .Name }}\n{{- $define := join .Name \"Define\" }}\n\nvar {{ $define }} {{ $serviceName }}Static\ntype  {{ $serviceName }}Static struct {\n{{- range .Methods }}\n    {{ .Name }} func (req *{{ .InputUsageName }}) (*{{ .OutputUsageName }}, error)\n{{- end }}\n}\n\n{{- range .Methods }}\n\nfunc {{ $serviceName }}{{ .Name }}(req *{{ .InputUsageName }}) (*{{ .OutputUsageName }}, error) {\n  if {{ $define }}.{{ .Name }} != nil {\n    return {{ $define }}.{{ .Name }}(req)\n  }\n  return nil, nil\n}\n{{- end }}\n{{ end }}\n\n{{- define \"controller\" -}}\npackage {{ .Package }}\n\nimport (\n  \"github.com/goal-web/contracts\"\n  \"github.com/goal-web/validation\"\n  \"{{ .ResponsePath }}\"\n  svc \"{{ .ImportPath }}\"\n  {{- range .Imports }}\n  {{- if notContains .Pkg \"results\" }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{ end -}}\n  {{- end }}\n)\n\n{{- $serviceName := .Name }}\n{{- $prefix := .Prefix }}\nfunc {{ .Name }}Router(router contracts.HttpRouter) {\n  routeGroup := router.Group(\"{{ $prefix }}\"{{ toMiddlewares .Middlewares }})\n  {{- range .Methods }}\n  {{- $controllerMethod := sprintf \"%s%s\" $serviceName .Name  }}\n  {{- $path := .Path  }}\n  {{- $middlewares := .Middlewares }}\n    {{- range .Method }}\n    routeGroup.{{ . }}(\"{{ $path }}\", {{ $controllerMethod }}{{ toMiddlewares $middlewares }})\n    {{- end }}\n  {{- end }}\n}\n\n\n{{- $usageName := .UsageName }}\n\n{{- range .Methods }}\nfunc {{ $serviceName }}{{ .Name }}(request contracts.HttpRequest) any {\n    var req {{ .InputUsageName }}\n    \n    if err:= request.Parse(&req); err != nil {\n      return response.ParseReqErr(err)\n    }\n    \n    if err := validation.Struct(req); err != nil {\n      return response.InvalidReq(err)\n    }\n  \n    resp, err := {{ $usageName }}{{ .Name }}(&req)\n    if err != nil {\n      return response.BizErr(err)\n    }\n    \n    return response.Success(resp)\n}\n{{- end }}\n{{ end }}")

func GetTemplate(path string) *template.Template {
	// 读取模板文件
	tmplContent, err := os.ReadFile(path)
	if err != nil {
		logs.Default().WithField("path", path).Warn("模板文件不存在，将使用默认模板")
		tmplContent = defaultTemplate
	}

	// 初始化模板，并添加函数映射
	tmpl, err := template.New("codegen").Funcs(template.FuncMap{
		"sub":             Sub,
		"goType":          GoType,
		"toLower":         strings.ToLower,
		"toCamelCase":     ToCamelCase,
		"toSnake":         ToSnakeCase,
		"toTags":          ToTags,
		"replaceSuffix":   strings.ReplaceAll,
		"toComments":      ToComments,
		"sprintf":         fmt.Sprintf,
		"contains":        strings.Contains,
		"notContains":     NotContains,
		"toMiddlewares":   ToMiddlewares,
		"getComment":      GetComment,
		"join":            StringJoin,
		"getIndexComment": GetIndexComment,
		"hasComment":      HasComment,
		"substring":       SubString,
		"hasMsgComment":   HasMsgComment,
	}).Parse(string(tmplContent))
	if err != nil {
		log.Fatal(err)
	}
	return tmpl
}
