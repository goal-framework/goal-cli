package gen

import (
	"fmt"
	"github.com/goal-web/supports/logs"
	"log"
	"os"
	"strings"
	"text/template"
)

var defaultTemplate = []byte("{{- define \"model\" -}}\npackage {{ .Package }}\n  \nimport (\n    \"encoding/json\"\n    \"github.com/goal-web/supports/logs\"\n    \"github.com/goal-web/contracts\"\n    \"github.com/goal-web/database/table\"\n    \"github.com/goal-web/supports/utils\"\n    {{- if ne (len .Relations) 0 }}\n    \"github.com/goal-web/collection\"\n    {{- end }}\n    {{- if .Model.Authenticatable }}\n    \"fmt\"\n    {{- end }}\n    {{- if hasMsgComment .Model \"@carbon\" }}\n    \"github.com/golang-module/carbon/v2\"\n    {{- end }}\n    {{- range .Imports }}\n    {{ .Alias }} \"{{ .Pkg }}\"\n    {{- end }}\n)\n\n{{- $modelName := .Model.Name }}\n{{- $rawName := .Model.RawName }}\n{{- $tableName := .Model.TableName }}\n{{- $primaryKey := .Model.PrimaryKey }}\n\n\nvar (\n    {{- range .Relations }}\n    {{ $rawName }}{{ .Name }}Relation contracts.RelationType = \"{{ .JSONName }}\"\n    {{- end }}\n)\n\n{{- $define := join $rawName \"Define\" }}\nvar {{ $define }} {{ $rawName }}Static\n\ntype {{ $rawName }}Static struct {\n\tHidden []string\n\tWith []contracts.RelationType\n\tAppends map[string]func(model *{{ $modelName }}) any\n\n  {{- range .Fields }}\n  {{ .Name }}Getter func(model *{{ $modelName }}, raw {{ goType . }}) {{ goType . }}\n  {{ .Name }}Setter func(model *{{ $modelName }}, raw {{ goType . }}) {{ goType . }}\n  {{- end }}\n\n  Saving   func(model *{{ $modelName }}) contracts.Exception\n  Saved    func(model *{{ $modelName }})\n  Updating func(model *{{ $modelName }}, fields contracts.Fields) contracts.Exception\n  Updated  func(model *{{ $modelName }}, fields contracts.Fields)\n  Deleting func(model *{{ $modelName }}) contracts.Exception\n  Deleted  func(model *{{ $modelName }})\n  PrimaryKeyGetter func(model *{{ $modelName }}) any\n}\n\nfunc init() {\n    {{- if hasMsgComment .Model \"@hidden\" }}\n    {{ $define }}.Hidden = append(\n        {{ $define }}.Hidden,\n        {{- range .Fields }}\n            {{- if hasComment .Comment \"@hidden\" }}\n            \"{{ .JSONName }}\",\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n\n    {{- if hasMsgComment .Model \"@with\" }}\n    {{ $define }}.With = append(\n        {{ $define }}.With,\n        {{- range .Relations }}\n            {{- if hasComment .Comment \"@with\" }}\n             {{ $rawName }}{{ .Name }}Relation,\n            {{- end }}\n        {{- end }}\n     )\n    {{- end }}\n}\n\nfunc New{{ $modelName }}(fields contracts.Fields) *{{ $modelName }} {\n  var model = {{ $modelName }}{\n    _raw: fields,\n  }\n  model.Set(fields)\n  return &model\n}\n\n{{- $queryName := replaceSuffix .Model.Name \"Model\" \"Query\" }}\n{{- $relationLen := sub (len .Relations) 1 }}\nfunc {{ $queryName }}() *table.Table[{{ $modelName }}] {\n  return table.NewQuery(\"{{ $tableName }}\", New{{ $modelName }}).SetPrimaryKey(\"{{ $primaryKey }}\"){{- if ne $relationLen -1 }} . {{- end }}\n    {{- range $index, $item := .Relations }}\n        {{- $relationItemType := goType . }}\n        {{- $relationQuery := replaceSuffix $relationItemType \"Model\" \"Query\"}}\n        {{- if hasComment .Comment \"@belongsTo\" }}\n            {{- $ownerKey := getIndexComment .Comment \"@belongsTo\" 0 \"id\" }}\n            SetRelation( // belongsTo\n            {{ $rawName }}{{ .Name }}Relation,\n                        func(item *{{ $modelName }}) any {\n                            return item.Get(\"{{ getIndexComment .Comment \"@belongsTo\" 1 (join .JSONName \"_id\") }}\")\n                        },\n                        func(keys []any) map[string][]any {\n                            var results = map[string][]any{}\n                            for key, values := range {{ $relationQuery }}().WhereIn(\"{{ $ownerKey }}\", keys).Get().GroupBy(\"{{ $ownerKey }}\") {\n                                results[key] = collection.New(values).ToAnyArray()\n                            }\n                            return results\n                        },\n                        func(item *{{ $modelName }}, value []any) {\n                            if len(value) > 0 {\n                                item.Set{{ .Name }}(value[0].(*{{ $relationItemType }}))\n                            } else {\n                                item.Set{{ .Name }}(nil)\n                            }\n                        },\n            ){{if ne $index $relationLen }}. {{end}}\n        {{- else if hasComment .Comment \"@hasOne\" }}\n         {{- $localKey := getIndexComment .Comment \"@hasOne\" 0 \"id\" }}\n         {{- $foreignKey := getIndexComment .Comment \"@hasOne\" 1 (join (toLower $rawName) \"_id\") }}\n                    SetRelation( // hasOne\n                    {{ $rawName }}{{ .Name }}Relation,\n                        func(item *{{ $modelName }}) any {\n                            return item.Get(\"{{ $localKey }}\")\n                        },\n                        func(keys []any) map[string][]any {\n                            var results = map[string][]any{}\n                            for key, values := range {{ $relationQuery }}().WhereIn(\"{{ $foreignKey }}\", keys).Get().GroupBy(\"{{ $foreignKey }}\") {\n                                results[key] = collection.New(values).ToAnyArray()\n                            }\n                            return results\n                        },\n                        func(item *{{ $modelName }}, value []any) {\n                            if len(value) > 0 {\n                                item.Set{{ .Name }}(value[0].(*{{ $relationItemType }}))\n                            } else {\n                                item.Set{{ .Name }}(nil)\n                            }\n                        },\n                    ){{if ne $index $relationLen }}. {{end}}\n        {{- end }}\n    {{- end }}\n}\n\n{{ toComments .Model.Name .Model.Comments }}\ntype {{ $modelName }} struct {\n  {{- range .Fields }}\n  {{- if hasComment .Comment \"@belongsTo\" }}\n  {{- else }}\n  {{ .Comments }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n  {{- end }}\n\n  _raw contracts.Fields\n  _update contracts.Fields\n  _append contracts.Fields\n  _single_relations map[contracts.RelationType]contracts.FieldsProvider\n  _hidden map[string]struct{}\n}\n\nfunc (model *{{ $modelName }}) Hidden(fields ...string) *{{ $modelName }} {\n    for _, field := range fields {\n        if model._hidden == nil {\n            model._hidden = map[string]struct{}{\n                field: struct{}{},\n            }\n        } else {\n            model._hidden[field] = struct{}{}\n        }\n\n    }\n\n    return model\n}\n\nfunc (model *{{ $modelName }}) Exists() bool {\n  return {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).Count() > 0\n}\n\nfunc (model *{{ $modelName }}) Save() contracts.Exception {\n  if model._update == nil {\n    return nil\n  }\n  if {{ $define }}.Saving != nil {\n    if err := {{ $define }}.Saving(model); err != nil {\n      return err\n    }\n  } \n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).UpdateE(model._update)\n  if err == nil {\n    model._update = nil\n    if {{ $define }}.Saved != nil {\n      {{ $define }}.Saved(model)\n    }\n  }\n  \n  return err\n}\n\nfunc (model *{{ $modelName }}) Set(fields contracts.Fields) {\n  for key, value := range fields {\n\n    switch key {\n  {{- range .Fields }}\n      case \"{{ .JSONName }}\":\n        switch v := value.(type) {\n                case {{ goType . }}:\n                  model.Set{{ .Name }}(v)\n                case func() {{ goType . }}:\n                  model.Set{{ .Name }}(v())\n                  {{- $type := goType . }}\n                  {{- if ne $type \"string\"}}\n                case string:\n                  {{- if eq $type \"[]byte\" }}\n                  model.Set{{ .Name }}([]byte(v))\n                  {{else}}\n                  var vd {{ goType . }}\n                  err := json.Unmarshal([]byte(v), &vd)\n                  if err != nil {\n                      logs.Default().Warn(\"Failed to Parse field \"+key)\n                      continue\n                  }\n                  model.Set{{ .Name }}(vd)\n                  {{end}}\n                  {{end}}\n                  {{- if ne $type \"[]byte\"}}\n                case []byte:\n                  {{- if eq $type \"string\" }}\n                  model.Set{{ .Name }}(string(v))\n                  {{else}}\n                  var vd {{ goType . }}\n                  err := json.Unmarshal(v, &vd)\n                  if err != nil {\n                      logs.Default().Warn(\"Failed to Parse field \"+key)\n                      continue\n                  }\n                  model.Set{{ .Name }}(vd)\n                  {{end}}\n                  {{end}}\n                }\n    {{- end }}\n\n    }\n\n  }\n}\n\nfunc (model *{{ $modelName }}) Only(key ...string) contracts.Fields {\n  var fields = make(contracts.Fields)\n  for _, k := range key {\n  {{- range .Fields }}\n    if k == \"{{ .JSONName }}\" {\n      fields[k] = model.Get{{ .Name }}()\n      continue\n    }\n  {{- end }}\n  \n    if {{ $define }}.Appends[k] != nil {\n     fields[k] = {{ $define }}.Appends[k](model)\n    }\n  }\n  return fields\n}\n\nfunc (model *{{ $modelName }}) Get(key string) any {\n  {{- range .Fields }}\n    if key == \"{{ .JSONName }}\" {\n      return model.Get{{ .Name }}()\n    }\n  {{- end }}\n\n\n    if model._append[key] != nil {\n      return model._append[key]\n    }\n\n    if model._single_relations[contracts.RelationType(key)] != nil {\n      return model._single_relations[contracts.RelationType(key)]\n    }\n\n  return nil\n}\n\nfunc (model *{{ $modelName }}) Except(keys ...string) contracts.Fields {\n  var excepts = map[string]struct{}{}\n  for _, k := range keys {\n    excepts[k] = struct{}{}\n  }\n  var fields = make(contracts.Fields)\n  for key, value := range model.ToFields() {\n    if _, ok := excepts[key]; ok {\n      continue\n    }\n    fields[key] = value\n  }\n  return fields\n}\n\nfunc (model *{{ $modelName }}) ToFields() contracts.Fields {\n  model.Hidden({{ $define }}.Hidden...)\n\n  fields := contracts.Fields{}\n\n    {{- range .Fields }}\n    if _,exists := model._hidden[\"{{ .JSONName }}\"]; !exists {\n        fields[\"{{ .JSONName }}\"] = model.Get{{ .Name }}()\n    }\n    {{- end }}\n\n  for key, f := range {{ $define }}.Appends {\n    fields[key] = f(model)\n  }\n\n  for key, f := range model._single_relations {\n    fields[string(key)] = f.ToFields()\n  }\n\n  return fields\n}\n\nfunc (model *{{ $modelName }}) Update(fields contracts.Fields) contracts.Exception {\n\n  if {{ $define }}.Updating != nil {\n    if err := {{ $define }}.Updating(model, fields); err != nil {\n      return err\n    }\n  }\n\n  if model._update != nil {\n    utils.MergeFields(model._update, fields)\n  }\n\n\n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).UpdateE(fields)\n  \n  if err == nil {\n    model.Set(fields)\n    model._update = nil\n    if {{ $define }}.Updated != nil {\n      {{ $define }}.Updated(model, fields)\n    }\n  }\n  \n  return err\n}\n\nfunc (model *{{ $modelName }}) Refresh() contracts.Exception {\n  fields, err := table.ArrayQuery(\"{{ $tableName }}\").Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).FirstE()\n  if err != nil {\n    return err\n  }\n\n  model.Set(*fields)\n  return nil\n}\n\nfunc (model *{{ $modelName }}) Delete() contracts.Exception {\n  \n  if {{ $define }}.Deleting != nil {\n    if err := {{ $define }}.Deleting(model); err != nil {\n      return err\n    }\n  }\n\n  _, err := {{ .Model.RawName }}Query().Where(\"{{ $primaryKey }}\", model.GetPrimaryKey()).DeleteE()\n  if err == nil && {{ $define }}.Deleted != nil {\n    {{ $define }}.Deleted(model)\n  }\n  \n  return err\n}\n\n  \nfunc (model *{{ $modelName }}) GetPrimaryKey() any {\n  if {{ $define }}.PrimaryKeyGetter != nil {\n    return {{ $define }}.PrimaryKeyGetter(model)\n  }\n  \n  return model.{{ toCamelCase $primaryKey }}\n}\n\n{{- if .Model.Authenticatable }}\nfunc (model *{{ $modelName }}) GetAuthenticatableKey() string {\n  return fmt.Sprintf(\"%v\", model.GetPrimaryKey())\n}\n\nfunc {{ .Model.RawName }}AuthProvider(identify string) contracts.Authenticatable {\n  return {{ .Model.RawName }}Query().Find(identify)\n}\n\n{{- end }}\n\n\n{{- range .Fields }}\n\nfunc (model *{{ $modelName }}) Get{{ .Name }}() {{ goType . }} {\n  if {{ $define }}.{{ .Name }}Getter != nil {\n    return {{ $define }}.{{ .Name }}Getter(model, model.{{ .Name }})\n  }\n  return model.{{ .Name }}\n}\n\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value {{ goType . }}) {\n  if {{ $define }}.{{ .Name }}Setter != nil {\n    value = {{ $define }}.{{ .Name }}Setter(model, value)\n  }\n\n  if model._update == nil {\n    model._update = contracts.Fields{\"{{ .JSONName }}\": value}\n  } else {\n    model._update[\"{{ .JSONName }}\"] = value\n  }\n  model.{{ .Name }} = value\n}\n\n{{- if hasComment .Comment \"@carbon\" }}\nfunc (model *{{ $modelName }}) Get{{ .Name }}Carbon() carbon.Carbon {\n  return carbon.Parse(model.Get{{ .Name }}())\n}\n{{- end }}\n\n\n{{- end }}\n\n{{- range .Relations }}\n{{- $relationType := join $rawName  .Name \"Relation\" }}\n{{- $relationItemType := goType . }}\n{{- $relationQuery := replaceSuffix $relationItemType \"Model\" \"Query\" }}\n\n{{- if (hasComment .Comment \"@belongsTo\") }}\nfunc (model *{{ $modelName }}) {{ .Name }}() *{{ goType . }} {\n    relation, exists := model._single_relations[{{ $relationType }}]\n    if !exists {\n        value := {{ $relationQuery }}().Where(\"{{ getIndexComment .Comment \"@belongsTo\" 0 \"id\" }}\", model.Get(\"{{ getIndexComment .Comment \"@belongsTo\" 1 (join .JSONName \"_id\") }}\")).First()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return relation.(*{{ goType . }})\n}\n\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value *{{ goType . }}) {\n    if model._single_relations == nil {\n        model._single_relations = map[contracts.RelationType]contracts.FieldsProvider{\n            {{ $relationType }}: value,\n        }\n        return\n    }\n    model._single_relations[{{ $relationType }}] = value\n}\n{{- else if (hasComment .Comment \"@hasOne\") }}\n{{- $localKey := getIndexComment .Comment \"@hasOne\" 0 \"id\" }}\n{{- $foreignKey := getIndexComment .Comment \"@hasOne\" 1 (join $rawName \"_id\") }}\n\nfunc (model *{{ $modelName }}) {{ .Name }}() *{{ goType . }} {\n    relation, exists := model._single_relations[{{ $relationType }}]\n    if !exists {\n        value := {{ $relationQuery }}().Where(\"{{ $foreignKey }}\", model.Get(\"{{ $localKey }}\")).First()\n        model.Set{{ .Name }}(value)\n        return value\n    }\n    return relation.(*{{ goType . }})\n}\n\nfunc (model *{{ $modelName }}) Set{{ .Name }}(value *{{ goType . }}) {\n    if model._single_relations == nil {\n        model._single_relations = map[contracts.RelationType]contracts.FieldsProvider{\n            {{ $relationType }}: value,\n        }\n        return\n    }\n    model._single_relations[{{ $relationType }}] = value\n}\n{{- end }}\n\n{{- end }}\n\n{{ end }}\n\n\n{{- define \"data\" -}}\npackage {{ .Package }}\n  \nimport (\n{{- range .Imports }}\n{{ .Alias }} \"{{ .Pkg }}\"\n{{- end }}\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\n{{ end }}\n\n{{- define \"request\" -}}\npackage {{ .Package }}\n  \nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n  \"github.com/goal-web/contracts\"\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\nfunc (model *{{ .Model.Name }}) ToFields() contracts.Fields {\n  if model == nil {\n    return nil\n  }\n  fields := contracts.Fields{\n  {{- range .Fields }}\n    \"{{ .JSONName }}\": model.{{ .Name }},\n  {{- end }}\n  }\n  return fields\n}\n\n{{ end }}\n\n{{- define \"result\" -}}\npackage {{ .Package }}\n    \nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n)\n\ntype {{ .Model.Name }} struct {\n  {{- range .Fields }}\n  {{ .Name }} {{ goType . }} `{{ toTags . }}`\n  {{- end }}\n}\n\n{{ end }}\n\n{{- define \"enum\" -}}\npackage {{ .Package }}\n\n{{- $enumName := .Name }}\ntype {{ .Name }} int\nconst (\n  {{- range .Values }}\n  {{- $FieldName := sprintf \"%s%s\" $enumName .Name }}\n\n  {{ toComments $FieldName .Comments }}\n  {{ $enumName }}{{ .Name }} {{ $enumName }} = {{ .Value }}\n  {{- end }}\n  {{ $enumName }}Unknown {{ $enumName }} = -1000\n      \n)\n  \n  \nfunc (item {{ $enumName }}) String() string {\n    switch item {\n      {{- range .Values }}\n        case {{ $enumName }}{{ .Name }}:\n          return \"{{ .Name }}\"\n      {{- end }}\n        default:\n          return \"Unknown\"\n  }\n}\n\nfunc (item {{ $enumName }}) Message() string {\n    switch item {\n      {{- range .Values }}\n        case {{ $enumName }}{{ .Name }}:\n          return \"{{ .Message }}\"\n      {{- end }}\n        default:\n          return \"Unknown\"\n  }\n}\n\nfunc Parse{{ $enumName }}FromString(msg string) {{ $enumName }} {\n    switch msg {\n    {{- range .Values }}\n        case \"{{ .Name }}\":\n          return {{ $enumName }}{{ .Name }}\n    {{- end }}\n        default:\n          return {{ $enumName }}Unknown\n  }\n}\n\n\n{{ end }}\n\n\n\n{{- define \"service\" -}}\npackage {{ .Package }}\n\nimport (\n  {{- range .Imports }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{- end }}\n)\n\n{{- $serviceName := .Name }}\n\n{{- range .Methods }}\n\nvar {{ $serviceName }}{{ .Name }}Handler func (req *{{ .InputUsageName }}) (*{{ .OutputUsageName }}, error)\nfunc {{ $serviceName }}{{ .Name }}(req *{{ .InputUsageName }}) (*{{ .OutputUsageName }}, error) {\n  if {{ $serviceName }}{{ .Name }}Handler != nil {\n    return {{ $serviceName }}{{ .Name }}Handler(req)\n  }\n  return nil, nil\n}\n{{- end }}\n{{ end }}\n\n{{- define \"controller\" -}}\npackage {{ .Package }}\n\nimport (\n  \"github.com/goal-web/contracts\"\n  \"github.com/goal-web/validation\"\n  \"{{ .ResponsePath }}\"\n  svc \"{{ .ImportPath }}\"\n  {{- range .Imports }}\n  {{- if notContains .Pkg \"results\" }}\n  {{ .Alias }} \"{{ .Pkg }}\"\n  {{ end -}}\n  {{- end }}\n)\n\n{{- $serviceName := .Name }}\n{{- $prefix := .Prefix }}\nfunc {{ .Name }}Router(router contracts.HttpRouter) {\n  routeGroup := router.Group(\"{{ $prefix }}\"{{ toMiddlewares .Middlewares }})\n  {{- range .Methods }}\n  {{- $controllerMethod := sprintf \"%s%s\" $serviceName .Name  }}\n  {{- $path := .Path  }}\n  {{- $middlewares := .Middlewares }}\n    {{- range .Method }}\n    routeGroup.{{ . }}(\"{{ $path }}\", {{ $controllerMethod }}{{ toMiddlewares $middlewares }})\n    {{- end }}\n  {{- end }}\n}\n\n\n{{- $usageName := .UsageName }}\n\n{{- range .Methods }}\nfunc {{ $serviceName }}{{ .Name }}(request contracts.HttpRequest) any {\n    var req {{ .InputUsageName }}\n    \n    if err:= request.Parse(&req); err != nil {\n      return response.ParseReqErr(err)\n    }\n    \n    if err := validation.Struct(req); err != nil {\n      return response.InvalidReq(err)\n    }\n  \n    resp, err := {{ $usageName }}{{ .Name }}(&req)\n    if err != nil {\n      return response.BizErr(err)\n    }\n    \n    return response.Success(resp)\n}\n{{- end }}\n{{ end }}")

func GetTemplate(path string) *template.Template {
	// 读取模板文件
	tmplContent, err := os.ReadFile(path)
	if err != nil {
		logs.Default().WithField("path", path).Warn("模板文件不存在，将使用默认模板")
		tmplContent = defaultTemplate
	}

	// 初始化模板，并添加函数映射
	tmpl, err := template.New("codegen").Funcs(template.FuncMap{
		"sub":             Sub,
		"goType":          GoType,
		"toLower":         strings.ToLower,
		"toCamelCase":     ToCamelCase,
		"toSnake":         ToSnakeCase,
		"toTags":          ToTags,
		"replaceSuffix":   strings.ReplaceAll,
		"toComments":      ToComments,
		"sprintf":         fmt.Sprintf,
		"contains":        strings.Contains,
		"notContains":     NotContains,
		"toMiddlewares":   ToMiddlewares,
		"getComment":      GetComment,
		"join":            StringJoin,
		"getIndexComment": GetIndexComment,
		"hasComment":      HasComment,
		"hasMsgComment":   HasMsgComment,
	}).Parse(string(tmplContent))
	if err != nil {
		log.Fatal(err)
	}
	return tmpl
}
